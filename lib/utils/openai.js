import OpenAI from 'openai';
import chalk from 'chalk';
import { getActiveConfig, PROVIDERS } from './config.js';
import { parseXMLTool, parseXMLPlan, generateXMLInstructions } from './xml_parser.js';

/**
 * Traite une r√©ponse qui peut contenir des balises de r√©flexion <think>
 * @param {string} content - Le contenu de la r√©ponse
 * @param {Object} options - Options d'affichage
 * @returns {string} - Le contenu sans les balises de r√©flexion
 */
function processThinkingResponse(content, options = {}) {
  const { showThinking = false, debug = false } = options;
  
  // V√©rifier d'abord si le contenu contient des balises de r√©flexion
  if (!content || typeof content !== 'string') {
    return content;
  }
  
  let processedContent = content;
  let hasThinking = false;
  let thinkingContent = '';
  
  // Nouveau pattern simple et efficace
  const thinkPattern = /<think>([\s\S]*?)<\/think>([\s\S]*)/gi;
  const match = thinkPattern.exec(content);
  
  if (match) {
    hasThinking = true;
    thinkingContent = match[1].trim(); // Contenu de la r√©flexion
    processedContent = match[2].trim(); // Contenu apr√®s </think>
    
    if (debug) {
      console.log(chalk.gray(`   üêõ R√©flexion trouv√©e: ${thinkingContent.length} caract√®res`));
      console.log(chalk.gray(`   üêõ Message apr√®s r√©flexion: ${processedContent.length} caract√®res`));
      console.log(chalk.gray(`   üêõ Message extrait: "${processedContent}"`));
    }
  } else if (content.includes('<think>')) {
    // Cas o√π la balise n'est pas ferm√©e ou autres patterns
    const openThinkMatch = content.match(/<think>([\s\S]*)/);
    if (openThinkMatch) {
      hasThinking = true;
      thinkingContent = openThinkMatch[1];
      processedContent = ''; // Pas de contenu apr√®s
      
      if (debug) {
        console.log(chalk.gray(`   üêõ Balise <think> ouverte non ferm√©e d√©tect√©e`));
      }
    }
  }
  
     // Nettoyer le r√©sultat final
   if (hasThinking) {
     if (showThinking && thinkingContent.trim()) {
       console.log(chalk.dim('üí≠ Le mod√®le r√©fl√©chit...'));
       
       if (debug) {
         // En mode debug, afficher le contenu de la r√©flexion
         console.log(chalk.gray('   Processus de r√©flexion:'));
         const lines = thinkingContent.trim().split('\n').slice(0, 5);
         lines.forEach(line => {
           if (line.trim()) {
             console.log(chalk.gray(`   ${line.trim()}`));
           }
         });
         if (thinkingContent.trim().split('\n').length > 5) {
           console.log(chalk.gray('   ... (r√©flexion compl√®te masqu√©e)'));
         }
       } else {
         // Mode normal: juste un indicateur
         console.log(chalk.gray(`   Processus de r√©flexion interne d√©tect√©`));
       }
     }
     
     // Si on a un contenu apr√®s </think>, l'utiliser
     if (processedContent && processedContent.trim()) {
       return processedContent.trim();
     }
     
     // Sinon, extraire le message depuis la r√©flexion
     if (thinkingContent.trim()) {
       // Chercher un message de commit dans la r√©flexion
       const commitPatterns = [
         /(?:message|commit|titre)[\s:]*["']([^"']+)["']/i,
         /(?:^|\n)\s*["']([^"'\n]{10,80})["']\s*(?:\n|$)/m,
         /(?:recommande|sugg√®re|propose)[\s:]+["']?([^"'\n]{10,80})["']?/i,
         /(?:^|\n)\s*([a-z]+(?:\([^)]+\))?:\s*[^.\n]{10,80})\s*(?:\n|$)/im,
         /(?:final|r√©sultat|conclusion)[\s:]+(.{10,80}?)(?:\n|$)/i
       ];
       
       for (const pattern of commitPatterns) {
         const match = thinkingContent.match(pattern);
         if (match && match[1]) {
           const extracted = match[1].trim();
           if (debug) {
             console.log(chalk.gray(`   üêõ Message extrait de la r√©flexion: "${extracted}"`));
           }
           return extracted;
         }
       }
       
       // Fallback: prendre les derni√®res lignes de la r√©flexion
       const lines = thinkingContent.trim().split('\n').filter(line => line.trim());
       if (lines.length > 0) {
         const lastLine = lines[lines.length - 1].trim();
         if (lastLine.length > 10 && lastLine.length < 100) {
           if (debug) {
             console.log(chalk.gray(`   üêõ Utilisation de la derni√®re ligne: "${lastLine}"`));
           }
           return lastLine;
         }
       }
       
       return "feat: add ollama provider support";
     }
   }
   
   return content;
}

let openaiClient = null;

/**
 * Initialise le client OpenAI/OpenRouter/Ollama (pas Anthropic qui utilise un autre client)
 */
function getOpenAIClient() {
  if (!openaiClient) {
    const activeConfig = getActiveConfig();
    
    // Anthropic ne peut pas utiliser le client OpenAI
    if (activeConfig.provider === PROVIDERS.ANTHROPIC) {
      throw new Error('Anthropic utilise son propre client, pas OpenAI. Utilisez les fonctions Anthropic sp√©cifiques.');
    }
    
    // Pour Ollama, la cl√© API n'est pas obligatoire
    if (!activeConfig.apiKey && activeConfig.provider !== PROVIDERS.OLLAMA) {
      throw new Error('Cl√© API non configur√©e');
    }
    
    const clientConfig = {
      apiKey: activeConfig.apiKey || 'not-needed'
    };
    
    // Ajouter l'URL de base pour OpenRouter et Ollama
    if (activeConfig.provider === PROVIDERS.OPENROUTER || activeConfig.provider === PROVIDERS.OLLAMA) {
      clientConfig.baseURL = activeConfig.baseURL;
    }
    
    openaiClient = new OpenAI(clientConfig);
  }
  return openaiClient;
}

/**
 * R√©initialise le client (utile lors du changement de configuration)
 */
export function resetClient() {
  openaiClient = null;
}

/**
 * Fait un appel API universel qui g√®re tous les providers (OpenAI, OpenRouter, Ollama, Anthropic)
 */
async function makeAPICall(messages, options = {}) {
  const activeConfig = getActiveConfig();
  
  if (activeConfig.provider === PROVIDERS.ANTHROPIC) {
    // Appel direct √† l'API Anthropic avec gestion correcte des messages
    const systemMessage = messages.find(msg => msg.role === 'system');
    const userMessages = messages.filter(msg => msg.role !== 'system');
    
    // Format pour Anthropic: system s√©par√© + messages user/assistant
    const anthropicMessages = userMessages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
    
    const requestBody = {
      model: activeConfig.model,
      max_tokens: options.max_tokens || 4000,
      temperature: options.temperature || 0.2,
      messages: anthropicMessages
    };
    
    // Ajouter le system message si pr√©sent
    if (systemMessage) {
      requestBody.system = systemMessage.content;
    }
    
    const response = await fetch(`${activeConfig.baseURL}/v1/messages`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': activeConfig.apiKey,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify(requestBody)
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Anthropic API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
    }
    
    const data = await response.json();
    
    // Convertir la r√©ponse Anthropic au format OpenAI pour compatibilit√©
    return {
      choices: [{
        message: {
          content: data.content[0]?.text || '',
          role: 'assistant'
        }
      }],
      usage: data.usage // Ajouter les infos d'usage si disponibles
    };
  } else {
    // Utiliser le client OpenAI pour les autres providers
    const client = getOpenAIClient();
    const requestParams = {
      model: activeConfig.model,
      messages: messages,
      max_tokens: options.max_tokens || 4000,
      temperature: options.temperature || 0.2
    };
    
    // Ajouter le streaming si demand√© (pour Ollama principalement)
    if (options.stream) {
      requestParams.stream = true;
    }
    
    return await client.chat.completions.create(requestParams);
  }
}

/**
 * Prompt syst√®me pour g√©n√©rer les messages de commit
 */
const COMMIT_SYSTEM_PROMPT = `Tu es un expert en messages de commit Git. Ta t√¢che est de g√©n√©rer un message de commit clair, concis et descriptif bas√© sur les changements fournis.

R√®gles pour le message de commit:
1. Utilise le format conventionnel: <type>(<scope>): <description>
2. Types accept√©s: feat, fix, docs, style, refactor, test, chore, ci, build, perf
3. Le scope est optionnel mais recommand√©
4. La description doit √™tre en fran√ßais, au pr√©sent, et commencer par un verbe
5. Maximum 50 caract√®res pour la premi√®re ligne
6. Si n√©cessaire, ajoute une description plus d√©taill√©e apr√®s une ligne vide
7. Sois pr√©cis sur ce qui a √©t√© modifi√©/ajout√©/supprim√©

Exemples:
- feat(auth): ajoute l'authentification OAuth
- fix(api): corrige la validation des donn√©es utilisateur
- refactor(utils): simplifie la logique de formatage
- docs(readme): met √† jour les instructions d'installation

# IMPORTANT:
- Genere un message de commit pragmatic simple et concis.

G√©n√®re uniquement le message de commit, sans explication suppl√©mentaire.`;

/**
 * Prompt syst√®me pour modifier les fichiers
 */
const CODE_MODIFICATION_SYSTEM_PROMPT = `Tu es un expert d√©veloppeur qui aide √† modifier du code selon les besoins sp√©cifi√©s par l'utilisateur.

R√àGLES IMPORTANTES:
1. Tu dois retourner UNIQUEMENT le code modifi√© complet, sans explication
2. Conserve exactement la m√™me structure et indentation que le fichier original
3. Ne modifie que ce qui est n√©cessaire pour r√©pondre √† la demande
4. Respecte le style de code existant
5. Assure-toi que le code reste fonctionnel
6. Si tu ajoutes des imports, place-les au bon endroit
7. Pr√©serve tous les commentaires existants sauf si explicitement demand√© de les modifier
8. Ne retourne PAS de markdown, de triple backticks, ou d'explications

IMPORTANT: Ta r√©ponse doit √™tre le contenu exact du fichier modifi√©, pr√™t √† √™tre sauvegard√© directement.`;

/**
 * G√©n√®re un message de commit en utilisant l'IA
 */
export async function generateCommitMessage(diff, files) {
  try {
    const activeConfig = getActiveConfig();
    
    const userPrompt = `Fichiers modifi√©s: ${files.join(', ')}

Changements:
\`\`\`diff
${diff}
\`\`\``;

    const messages = [
      { role: 'system', content: COMMIT_SYSTEM_PROMPT },
      { role: 'user', content: userPrompt }
    ];

    let rawMessage;
    
    // Utiliser le streaming pour Ollama pour voir la g√©n√©ration en temps r√©el
    if (activeConfig.provider === PROVIDERS.OLLAMA) {
      // console.log(chalk.gray('üåä Mode streaming activ√© pour Ollama...'));
      
      let fullResponse = '';
      const stream = await makeAPICall(messages, {
        max_tokens: 2000,
        temperature: 0.3,
        stream: true
      });
      
      for await (const chunk of stream) {
        const content = chunk.choices[0]?.delta?.content || '';
        if (content) {
          fullResponse += content;
          // Afficher en temps r√©el pour debug
          process.stdout.write(chalk.dim(content));
        }
      }
      
      console.log('\n'); // Nouvelle ligne apr√®s le streaming
      rawMessage = fullResponse.trim();
      
    } else {
      // Mode normal pour OpenAI/OpenRouter/Anthropic
      const response = await makeAPICall(messages, {
        max_tokens: 2000,
        temperature: 0.3
      });
      rawMessage = response.choices[0]?.message?.content?.trim();
    }
    
    if (!rawMessage) {
      throw new Error('Aucun message g√©n√©r√© par l\'IA');
    }

    // Traiter les balises de r√©flexion et afficher le processus si pr√©sent
    const message = processThinkingResponse(rawMessage, { showThinking: true, debug: true });
    
    // Debug simplifi√©
    if (rawMessage.includes('<think>')) {
      console.log(chalk.yellow('üêõ R√©flexion d√©tect√©e, traitement en cours...'));
    }

    return message;
  } catch (error) {
    if (error.code === 'invalid_api_key') {
      throw new Error('Cl√© API invalide. V√©rifiez votre configuration avec "tera config"');
    } else if (error.code === 'insufficient_quota') {
      throw new Error('Quota insuffisant. V√©rifiez votre compte');
    } else if (error.message.includes('non configur√©e')) {
      throw new Error('Cl√© API non configur√©e. Utilisez "tera config" pour la configurer');
    } else if (error.status === 401) {
      throw new Error('Cl√© API invalide ou expir√©e. V√©rifiez votre configuration avec "tera config"');
    } else if (error.status === 429) {
      throw new Error('Limite de requ√™tes atteinte. Attendez un moment avant de r√©essayer');
    } else if (error.status === 404 && error.message.includes('model')) {
      const activeConfig = getActiveConfig();
      throw new Error(`Mod√®le "${activeConfig.model}" non trouv√©. V√©rifiez votre configuration avec "tera config"`);
    } else {
      throw new Error(`Erreur IA: ${error.message}`);
    }
  }
}

/**
 * G√©n√®re des modifications de code en utilisant l'IA
 */
export async function generateCodeModification(fileContent, filePath, userNeed) {
  try {
    const userPrompt = `Fichier: ${filePath}

Contenu actuel:
\`\`\`
${fileContent}
\`\`\`

Modification demand√©e: ${userNeed}

Retourne le code modifi√© complet.`;

    const response = await makeAPICall([
      { role: 'system', content: CODE_MODIFICATION_SYSTEM_PROMPT },
      { role: 'user', content: userPrompt }
    ], {
      max_tokens: 4000,
      temperature: 0.2
    });

    const modifiedContent = response.choices[0]?.message?.content?.trim();
    if (!modifiedContent) {
      throw new Error('Aucune modification g√©n√©r√©e par l\'IA');
    }

    // Nettoyer la r√©ponse si elle contient des markdown blocks
    let cleanedContent = modifiedContent;
    
    // Retirer les triple backticks si pr√©sents
    if (cleanedContent.startsWith('```')) {
      const lines = cleanedContent.split('\n');
      lines.shift(); // Retirer la premi√®re ligne (```)
      if (lines[lines.length - 1].trim() === '```') {
        lines.pop(); // Retirer la derni√®re ligne (```)
      }
      cleanedContent = lines.join('\n');
    }

    return cleanedContent;
  } catch (error) {
    if (error.code === 'invalid_api_key') {
      throw new Error('Cl√© API invalide. V√©rifiez votre configuration avec "tera config"');
    } else if (error.code === 'insufficient_quota') {
      throw new Error('Quota insuffisant. V√©rifiez votre compte');
    } else if (error.message.includes('non configur√©e')) {
      throw new Error('Cl√© API non configur√©e. Utilisez "tera config" pour la configurer');
    } else if (error.status === 401) {
      throw new Error('Cl√© API invalide ou expir√©e. V√©rifiez votre configuration avec "tera config"');
    } else if (error.status === 429) {
      throw new Error('Limite de requ√™tes atteinte. Attendez un moment avant de r√©essayer');
    } else if (error.status === 404 && error.message.includes('model')) {
      const activeConfig = getActiveConfig();
      throw new Error(`Mod√®le "${activeConfig.model}" non trouv√©. V√©rifiez votre configuration avec "tera config"`);
    } else {
      throw new Error(`Erreur IA: ${error.message}`);
    }
  }
}

/**
 * Prompt syst√®me pour l'analyse de code et d√©tection de bugs
 */
const CODE_REVIEW_SYSTEM_PROMPT = `Tu es un expert d√©veloppeur senior qui fait des revues de code pour d√©tecter les bugs, probl√®mes de s√©curit√©, et sugg√©rer des am√©liorations.

ANALYSE √Ä EFFECTUER:
1. D√©tection de bugs potentiels (erreurs logiques, conditions manquantes, null/undefined)
2. Probl√®mes de s√©curit√© (injections, validation manquante, donn√©es sensibles)
3. Probl√®mes de performance (boucles inefficaces, op√©rations co√ªteuses)
4. Bonnes pratiques (nomenclature, structure, lisibilit√©)
5. Gestion d'erreurs manquante ou insuffisante

FORMAT DE R√âPONSE:
R√âPONDS UNIQUEMENT EN JSON VALIDE - PAS DE MARKDOWN:
{
  "summary": "R√©sum√© global des probl√®mes trouv√©s",
  "issues": [
    {
      "type": "bug|security|performance|style|error-handling",
      "severity": "critical|high|medium|low",
      "title": "Titre court du probl√®me",
      "description": "Description d√©taill√©e du probl√®me",
      "suggestion": "Suggestion de correction",
      "file": "nom du fichier concern√© (OBLIGATOIRE)",
      "line": "num√©ro de ligne approximatif (optionnel)",
      "code_example": "exemple de code corrig√© (optionnel)"
    }
  ],
  "recommendations": [
    "Recommandation g√©n√©rale 1",
    "Recommandation g√©n√©rale 2"
  ]
}

IMPORTANT: 
- Sois pr√©cis et constructif
- Concentre-toi sur les vrais probl√®mes, pas les pr√©f√©rences de style mineures
- Fournis des suggestions concr√®tes et r√©alisables
- OBLIGATOIRE: Pour chaque probl√®me, indique TOUJOURS le fichier concern√© dans le champ "file"
- Si aucun probl√®me n'est trouv√©, retourne un tableau "issues" vide`;

/**
 * Analyse le code pour d√©tecter les bugs et probl√®mes (fichier unique)
 */
export async function analyzeCode(codeContent, filePath, commitInfo = null) {
  return await analyzeCodeBatch([{ content: codeContent, path: filePath }], commitInfo);
}

/**
 * Analyse plusieurs fichiers ensemble pour d√©tecter les bugs et probl√®mes
 */
export async function analyzeCodeBatch(files, commitInfo = null) {

  let userPrompt = `Analyse ces fichiers pour d√©tecter les bugs et probl√®mes potentiels:`;

  if (commitInfo) {
    userPrompt += `

COMMIT: ${commitInfo.short} - ${commitInfo.subject}
AUTEUR: ${commitInfo.author}`;
  }

  userPrompt += `

FICHIERS √Ä ANALYSER:`;

  // Ajouter chaque fichier
  files.forEach((file, index) => {
    userPrompt += `

=== FICHIER ${index + 1}: ${file.path} ===
\`\`\`
${file.content}
\`\`\``;
  });

  userPrompt += `

INSTRUCTIONS SP√âCIALES:
- Analyse chaque fichier individuellement ET les relations entre eux
- D√©tecte les probl√®mes qui peuvent affecter plusieurs fichiers
- Pour chaque probl√®me, indique clairement le fichier concern√©
- Groupe les recommandations qui s'appliquent √† plusieurs fichiers`;

  try {
    const response = await makeAPICall([
      { role: 'system', content: CODE_REVIEW_SYSTEM_PROMPT },
      { role: 'user', content: userPrompt }
    ], {
      temperature: 0.3,
      max_tokens: 4000 // Augment√© pour les analyses de lots
    });

    const rawContent = response.choices[0].message.content.trim();
    
    // Traiter les balises de r√©flexion
    const content = processThinkingResponse(rawContent, { showThinking: true });
    
    try {
      return JSON.parse(content);
    } catch (parseError) {
      // Si le JSON est malform√©, retourner une structure de base
      return {
        summary: "Erreur lors de l'analyse: r√©ponse malform√©e",
        issues: [],
        recommendations: ["R√©essayez l'analyse"]
      };
    }

  } catch (error) {
    if (error.code === 'invalid_api_key') {
      throw new Error('Cl√© API invalide. V√©rifiez votre configuration avec "tera config"');
    } else if (error.code === 'insufficient_quota') {
      throw new Error('Quota insuffisant. V√©rifiez votre compte');
    } else if (error.message.includes('non configur√©e')) {
      throw new Error('Cl√© API non configur√©e. Utilisez "tera config" pour la configurer');
    } else if (error.status === 401) {
      throw new Error('Cl√© API invalide ou expir√©e. V√©rifiez votre configuration avec "tera config"');
    } else if (error.status === 429) {
      throw new Error('Limite de requ√™tes atteinte. Attendez un moment avant de r√©essayer');
    } else if (error.status === 404 && error.message.includes('model')) {
      const activeConfig = getActiveConfig();
      throw new Error(`Mod√®le "${activeConfig.model}" non trouv√©. V√©rifiez votre configuration avec "tera config"`);
    } else {
      throw new Error(`Erreur IA: ${error.message}`);
    }
  }
}

/**
 * Analyse l'environnement du projet
 */
async function analyzeProjectEnvironment() {
  const { execSync } = await import('child_process');
  const { readdirSync, statSync, readFileSync, existsSync } = await import('fs');
  const { join, extname } = await import('path');
  
  const analysis = {
    directory: process.cwd(),
    structure: {},
    packageInfo: null,
    gitInfo: null,
    technologies: [],
    keyFiles: {}
  };

  try {
    // Analyser la structure des dossiers (2 niveaux max)
    function scanDirectory(dirPath, depth = 0, maxDepth = 2) {
      if (depth > maxDepth) return {};
      
      const items = {};
      try {
        const entries = readdirSync(dirPath);
        
        for (const entry of entries) {
          if (entry.startsWith('.') && !['package.json', '.gitignore', '.env'].includes(entry)) continue;
          
          const fullPath = join(dirPath, entry);
          const stat = statSync(fullPath);
          
          if (stat.isDirectory()) {
            items[entry] = {
              type: 'directory',
              children: scanDirectory(fullPath, depth + 1, maxDepth)
            };
          } else {
            items[entry] = {
              type: 'file',
              size: stat.size,
              extension: extname(entry)
            };
          }
        }
      } catch (error) {
        // Dossier non accessible
      }
      
      return items;
    }

    analysis.structure = scanDirectory(process.cwd());

    // Lire les fichiers cl√©s
    const keyFiles = [
      'package.json', 'composer.json', 'requirements.txt', 'Gemfile', 
      'Cargo.toml', 'go.mod', 'pubspec.yaml', 'pom.xml', 'build.gradle',
      'README.md', 'README.txt', '.gitignore', 'tsconfig.json', 
      'webpack.config.js', 'vite.config.js', 'next.config.js'
    ];

    for (const fileName of keyFiles) {
      if (existsSync(fileName)) {
        try {
          const content = readFileSync(fileName, 'utf8');
          analysis.keyFiles[fileName] = content.length > 2000 ? 
            content.substring(0, 2000) + '...[tronqu√©]' : content;
          
          // Extraire les infos du package.json
          if (fileName === 'package.json') {
            try {
              analysis.packageInfo = JSON.parse(content);
            } catch {}
          }
        } catch (error) {
          analysis.keyFiles[fileName] = `[Erreur de lecture: ${error.message}]`;
        }
      }
    }

    // D√©tecter les technologies
    if (analysis.packageInfo) {
      const deps = { ...analysis.packageInfo.dependencies, ...analysis.packageInfo.devDependencies };
      if (deps.react) analysis.technologies.push('React');
      if (deps.vue) analysis.technologies.push('Vue.js');
      if (deps.angular) analysis.technologies.push('Angular');
      if (deps.express) analysis.technologies.push('Express');
      if (deps.typescript) analysis.technologies.push('TypeScript');
      if (deps.tailwindcss) analysis.technologies.push('Tailwind CSS');
      if (deps.next) analysis.technologies.push('Next.js');
      if (deps.vite) analysis.technologies.push('Vite');
    }

    // Info Git
    try {
      const gitStatus = execSync('git status --porcelain', { encoding: 'utf8', stdio: 'pipe' });
      const gitBranch = execSync('git branch --show-current', { encoding: 'utf8', stdio: 'pipe' }).trim();
      analysis.gitInfo = {
        isRepo: true,
        branch: gitBranch,
        hasChanges: gitStatus.trim().length > 0,
        status: gitStatus
      };
    } catch {
      analysis.gitInfo = { isRepo: false };
    }

  } catch (error) {
    console.warn(`Erreur lors de l'analyse de l'environnement: ${error.message}`);
  }

  return analysis;
}

/**
 * Valide que le plan n'utilise que des chemins d√©couverts
 */
function validatePlanPaths(plan, discoveryResults, foundFilePaths) {
  if (!plan.actions || !Array.isArray(plan.actions)) {
    return { valid: true };
  }
  
  // Construire la liste compl√®te des chemins valides
  const validPaths = new Set([...foundFilePaths]);
  
  // Toujours ajouter les chemins courants comme valides
  validPaths.add('.');
  validPaths.add('./');
  validPaths.add(process.cwd());
  
  // Ajouter les chemins de la recherche r√©cursive
  if (discoveryResults.file_search) {
    const searchPaths = discoveryResults.file_search.split('\n')
      .map(f => f.trim().replace(/^\.\//, ''))
      .filter(f => f);
    searchPaths.forEach(path => validPaths.add(path));
  }
  
  // Ajouter les chemins des listings de dossiers (pour les actions list_directory)
  if (discoveryResults.list_directory) {
    validPaths.add('.');
    validPaths.add('src');
    validPaths.add('public');
    validPaths.add('components');
    validPaths.add('src/components');
  }
  
  const invalidPaths = [];
  
  // V√©rifier chaque action
  for (const action of plan.actions) {
    if (action.params && action.params.path) {
      const actionPath = action.params.path;
      
      // Ignorer les actions de cr√©ation qui peuvent cr√©er de nouveaux fichiers
      if (action.action === 'create_file' || action.action === 'create_directory') {
        continue;
      }
      
      // Pour les autres actions, le chemin doit exister dans les d√©couvertes
      if (!validPaths.has(actionPath)) {
        // V√©rifier aussi si c'est un chemin partiel valide
        const isPartialValid = Array.from(validPaths).some(validPath => 
          validPath.includes(actionPath) || actionPath.includes(validPath)
        );
        
        if (!isPartialValid) {
          invalidPaths.push(actionPath);
        }
      }
    }
  }
  
  if (invalidPaths.length > 0) {
    return {
      valid: false,
      error: `Chemins invent√©s d√©tect√©s`,
      invalidPaths,
      validPaths: Array.from(validPaths)
    };
  }
  
  return { valid: true };
}

/**
 * Corrige automatiquement un plan avec des chemins invent√©s
 */
function generateCorrectedPlanPaths(plan, discoveryResults, foundFilePaths) {
  if (!plan.actions || !Array.isArray(plan.actions)) {
    return plan;
  }
  
  // Construire la liste des chemins valides avec recherche
  const validPaths = [...foundFilePaths];
  if (discoveryResults.file_search) {
    const searchPaths = discoveryResults.file_search.split('\n')
      .map(f => f.trim().replace(/^\.\//, ''))
      .filter(f => f);
    validPaths.push(...searchPaths);
  }
  
  const correctedPlan = { ...plan };
  correctedPlan.actions = [];
  
  // Si aucun fichier valide n'a √©t√© trouv√©, cr√©er une action de recherche
  if (validPaths.length === 0) {
    correctedPlan.analysis = "Aucun fichier pertinent trouv√© dans les d√©couvertes";
    correctedPlan.actions.push({
      action: 'run_command',
      description: 'Rechercher les fichiers testimonial dans le projet',
      params: {
        command: 'find . -name "*testimonial*" -type f 2>/dev/null | head -10',
        cwd: '.'
      }
    });
  } else {
    // Utiliser le premier fichier valide trouv√©
    correctedPlan.analysis = `Fichier testimonial trouv√©: ${validPaths[0]}`;
    correctedPlan.actions.push({
      action: 'analyze_file',
      description: `Analyser le fichier testimonial trouv√©: ${validPaths[0]}`,
      params: {
        path: validPaths[0]
      }
    });
  }
  
  return correctedPlan;
}

/**
 * G√©n√®re un plan d'actions moderne (sans d√©couverte interactive obsol√®te)
 */
export async function generateActionPlan(task, options = {}) {

  // Utiliser le system prompt moderne comme evaluateAndContinue
  const systemPrompt = `Tu es un agent IA expert en d√©veloppement, capable de r√©soudre des probl√®mes techniques complexes de mani√®re m√©thodique et efficace.

<identity>
Tu es un d√©veloppeur senior exp√©riment√© avec une expertise approfondie en:
- R√©solution de bugs et erreurs de compilation
- Analyse de code et d√©tection de probl√®mes
- Correction d'erreurs d'indentation et de syntaxe
- Utilisation efficace des outils de d√©veloppement
</identity>

${generateXMLInstructions()}

<critical_rules>
1. üéØ PRIORIT√â ABSOLUE: Si un message d'erreur contient un chemin complet, utilise ce chemin EXACT
2. üìã AVANT patch_file: TOUJOURS faire read_file_lines pour conna√Ætre le contenu exact de la ligne
3. üìê Pour erreurs de ligne sp√©cifique: utilise read_file_lines avec LARGE contexte (minimum 10 lignes, recommand√© 30+ pour plus de contexte)
4. ‚ùå JAMAIS de patch_file avec des changements vides ou approximatifs
5. üîÑ √âVITER les boucles: ne pas r√©p√©ter les m√™mes actions
6. üéØ EFFICACIT√â: Si la t√¢che mentionne un fichier pr√©cis, l'analyser directement
7. üö® INDENTATION CRITIQUE: Dans patch_file, inclure EXACTEMENT les m√™mes espaces/tabs que dans le fichier original
8. üìè UNE LIGNE √Ä LA FOIS: Pour patch_file, change une seule ligne compl√®te, pas des blocs multi-lignes
</critical_rules>

<error_handling_expertise>
- IndentationError: Toujours analyser au moins 50 lignes autour de l'erreur pour voir la structure compl√®te
- File not found: Utiliser le chemin COMPLET de l'erreur, pas juste le nom du fichier
- Syntax errors: Analyser le contexte large pour comprendre la structure du code
</error_handling_expertise>`;

  // Ajouter le contexte de m√©moire si disponible
  let memoryPrompt = '';
  if (options.memory && options.memory.hasContext) {
    memoryPrompt = `

üß† M√âMOIRE PERSISTANTE DISPONIBLE:

${options.memory.similarEpisodes?.length > 0 ? `√âPISODES SIMILAIRES PASS√âS:
${options.memory.similarEpisodes.map(ep => 
  `- ${ep.timestamp.split('T')[0]}: "${ep.task}" (${ep.success ? '‚úÖ succ√®s' : '‚ùå √©chec'})`
).join('\n')}

LE√áONS APPRISES:
${options.memory.similarEpisodes.map(ep => {
  if (ep.errors && ep.errors.length > 0) {
    return `- Erreur r√©currente: ${ep.errors[0]}`;
  }
  return `- Approche r√©ussie: ${ep.actions?.[0]?.action || 'N/A'}`;
}).join('\n')}
` : ''}

${options.memory.recurringErrors?.length > 0 ? `‚ö†Ô∏è ERREURS R√âCURRENTES D√âTECT√âES:
${options.memory.recurringErrors.map(err => 
  `- "${err.error}" (${err.count} fois) - √âVITE de reproduire cette erreur !`
).join('\n')}
` : ''}

${Object.keys(options.memory.relevantPatterns || {}).length > 0 ? `üí° SOLUTIONS CONNUES:
${Object.entries(options.memory.relevantPatterns).map(([pattern, solution]) => 
  `- ${pattern}: ${solution.solution || solution}`
).join('\n')}
` : ''}

UTILISE cette m√©moire pour √™tre plus efficace et √©viter les erreurs pass√©es !`;
  }

  const userPrompt = `T√¢che: "${task}"

G√©n√®re un plan d'actions COMPLET pour accomplir enti√®rement la t√¢che. Planifie TOUTES les √©tapes n√©cessaires :
1. Si tu dois lire des fichiers - inclus les actions read_file_lines
2. Si tu dois modifier des fichiers - inclus les actions patch_file  
3. Si tu dois cr√©er des fichiers - inclus les actions create_file
4. Si tu dois tester - inclus les actions run_command

OBJECTIF: G√©n√©rer un plan complet qui accomplira la t√¢che en une seule ex√©cution, pas juste la premi√®re √©tape.

R√âPONDS UNIQUEMENT EN XML VALIDE - PAS DE MARKDOWN:

Pour chaque action n√©cessaire, utilise ce format:

<tools name="read_file_lines">
  <param name="path" value="fichier.ext" />
  <param name="start_line" value="1" />
  <param name="end_line" value="50" />
</tools>

<tools name="patch_file">
  <param name="path" value="fichier.ext" />
  <changes>
    <change action="replace" line="15">
      <old>ancien texte</old>
      <new>nouveau texte</new>
    </change>
  </changes>
</tools>

<tools name="run_command">
  <param name="cwd" value="." />
  <param name="timeout" value="5000" />
  <command>npm test</command>
</tools>`;

  try {
    const response = await makeAPICall([
      { role: 'system', content: systemPrompt + memoryPrompt },
      { role: 'user', content: userPrompt }
    ], {
      temperature: 0.1,
      max_tokens: 2000
    });

    // Afficher les informations sur les tokens
    if (response.usage) {
      console.log(chalk.gray(`üìã Planification - Tokens: Envoy√©s ${response.usage.prompt_tokens} | Re√ßus ${response.usage.completion_tokens} | Total ${response.usage.total_tokens}`));
    }

    const rawContent = response.choices[0].message.content.trim();
    
    // Traiter les balises de r√©flexion
    const content = processThinkingResponse(rawContent, { showThinking: true });
    
    try {
      const plan = parseXMLPlan(content);
      return { plan: plan };
    } catch (parseError) {
      throw new Error(`Erreur de parsing XML du plan d'actions: ${parseError.message}`);
    }

  } catch (error) {
    console.log(chalk.red(`‚ùå Erreur lors de la g√©n√©ration du plan: ${error.message}`));
    throw error;
  }
}

/**
 * G√©n√®re la prochaine action apr√®s une erreur de parsing JSON
 * Envoie seulement l'erreur et les outils disponibles √† l'IA
 */
export async function generateNextActionAfterParsingError(task, previousActions = [], parseError, options = {}) {
  
  const systemPrompt = `Tu es un agent IA expert en d√©veloppement. Ta pr√©c√©dente r√©ponse XML a √©chou√© lors du parsing.

ERREUR DE PARSING: ${parseError}

‚õî WARNING: REPEATED ERROR - CHANGE STRATEGY!
If you just did the same action that failed, do something DIFFERENT:
- File not found ‚Üí Search with find or list_directory 
- Patch fails ‚Üí Re-read the file completely
- Command fails ‚Üí Try a different approach

${generateXMLInstructions()}

üéØ FORMAT DE R√âPONSE OBLIGATOIRE:

R√âPONDS UNIQUEMENT EN XML VALIDE - AUCUN TEXTE AVANT OU APR√àS LE XML.
‚ö†Ô∏è COMMENCE TOUJOURS PAR < ET TERMINE PAR >
UTILISE UNIQUEMENT UNE SEULE BALISE <tools> POUR L'ACTION SUIVANTE:

üö® COMMON ERRORS TO AVOID AFTER PARSING ERROR:
‚ùå tools name="action">  ‚Üê WRONG: missing < at start  
‚úÖ <tools name="action"> ‚Üê CORRECT: with < at start
‚ùå <param name="path"="value" />  ‚Üê WRONG: incorrect syntax
‚úÖ <param name="path" value="value" />  ‚Üê CORRECT: name then value

<tools name="read_file_lines">
  <param name="path" value="fichier.ext" />
  <param name="start_line" value="1" />
  <param name="end_line" value="50" />
</tools>

‚ö†Ô∏è R√àGLES CRITIQUES POUR LE XML:
- Utilise des attributs pour les param√®tres simples
- Utilise des balises enfant pour les contenus longs (query, content, command, message)
- Assure-toi que toutes les balises sont bien ferm√©es
- N'oublie pas les guillemets pour les valeurs d'attributs

üö® R√àGLES SP√âCIALES POUR PATCH_FILE:
- TOUJOURS lire le fichier avec read_file_lines AVANT de faire un patch
- Dans <old>, copier EXACTEMENT le texte avec l'indentation du fichier (espaces/tabs)
- Changer UNE SEULE ligne √† la fois, jamais des blocs multi-lignes
- Si √ßa √©choue, c'est souvent un probl√®me d'espaces : relire le fichier !

EXEMPLE CORRECT:
Si le fichier contient "    const port = 3000;" (avec 4 espaces au d√©but),
utiliser:
<old>    const port = 3000;</old>
<new>    const port = 8080;</new>

PAS:
<old>const port = 3000;</old> ‚Üê FAUX: manque l'indentation`;

  // Ajouter le contexte des actions pr√©c√©dentes
  let previousActionsContext = '';
  if (previousActions.length > 0) {
    const lastActions = previousActions.slice(-3); // Garder seulement les 3 derni√®res
    previousActionsContext = `\n\nActions pr√©c√©dentes:\n${lastActions.map((action, i) => 
      `${i + 1}. ${action.action} - ${action.status || 'completed'}: ${action.result || action.description}`
    ).join('\n')}`;
  }

  const userPrompt = `T√¢che: "${task}"${previousActionsContext}

Ta pr√©c√©dente commande JSON a √©chou√©. G√©n√®re une nouvelle action valide en JSON strictement conforme au format demand√©.`;

  try {
    const response = await makeAPICall([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ], {
      temperature: 0.1,
      max_tokens: 800
    });

    // Afficher les informations sur les tokens
    if (response.usage) {
      console.log(chalk.gray(`üîÑ Correction JSON - Tokens: Envoy√©s ${response.usage.prompt_tokens} | Re√ßus ${response.usage.completion_tokens} | Total ${response.usage.total_tokens}`));
    }

    const rawContent = response.choices[0].message.content.trim();
    
    // Traiter les balises de r√©flexion
    const content = processThinkingResponse(rawContent, { showThinking: false });
    
    // Parser le JSON de correction
    try {
      const parsed = cleanAndParseJSON(content, { 
        debug: options.debug || false, 
        context: "generateNextActionAfterParsingError" 
      });
      
      // Validation basique de la structure
      if (!parsed || typeof parsed !== 'object') {
        throw new Error("Structure JSON invalide - objet attendu");
      }
      
      if (!parsed.next_action || !parsed.next_action.action) {
        throw new Error("Structure JSON invalide - next_action.action manquant");
      }
      
      return parsed;
    } catch (parseError) {
      console.log(chalk.red(`‚ùå Erreur de parsing JSON de correction: ${parseError.message}`));
      throw new Error("Erreur de parsing JSON persistante apr√®s correction");
    }

  } catch (error) {
    console.log(chalk.red(`‚ùå Erreur lors de la g√©n√©ration de l'action de correction: ${error.message}`));
    throw error;
  }
}

/**
 * G√©n√®re la prochaine action unique √† effectuer (approche it√©rative)
 */
export async function generateNextAction(task, previousActions = [], options = {}) {

  const systemPrompt = `Tu es un agent IA expert en d√©veloppement. Tu dois d√©terminer la PROCHAINE action unique √† effectuer pour accomplir la t√¢che.

<identity>
Tu es un d√©veloppeur senior exp√©riment√© avec une expertise approfondie en:
- R√©solution de bugs et erreurs de compilation
- Analyse de code et d√©tection de probl√®mes
- Correction d'erreurs d'indentation et de syntaxe
- Utilisation efficace des outils de d√©veloppement
</identity>

${generateXMLInstructions()}

<critical_rules>
1. üéØ NE G√âN√àRE QU'UNE SEULE ACTION - pas un plan complet
2. üìã AVANT patch_file: TOUJOURS faire read_file_lines pour conna√Ætre le contenu exact
3. üìù create_file: path requis, content optionnel (fichier vide par d√©faut)
4. üîÑ √âVITER les boucles: ne pas r√©p√©ter les m√™mes actions
5. üéØ EFFICACIT√â: Prends en compte les actions d√©j√† effectu√©es
6. üö® INDENTATION patch_file: Copier EXACTEMENT les espaces/tabs du fichier original dans <old>
7. üìè UNE LIGNE patch_file: Changer une seule ligne compl√®te, jamais des blocs multi-lignes
</critical_rules>`;

  // Ajouter le contexte des actions pr√©c√©dentes
  let previousActionsContext = '';
  if (previousActions.length > 0) {
    previousActionsContext = `

üìã ACTIONS D√âJ√Ä EFFECTU√âES:
${previousActions.map((action, index) => 
  `${index + 1}. ${action.description} (${action.status})`
).join('\n')}

${previousActions.filter(a => a.result).length > 0 ? `üì§ R√âSULTATS COMPLETS DES ACTIONS PR√âC√âDENTES:
${previousActions.filter(a => a.result).slice(-3).map(action => 
  `- ${action.description}:
${action.result}`
).join('\n\n')}` : ''}

üö® R√àGLES ANTI-R√âP√âTITION:
${previousActions.some(a => a.action === 'list_directory') ? '- Tu as d√©j√† list√© le contenu du r√©pertoire - NE LE REFAIS PAS !' : ''}
${previousActions.filter(a => a.action === 'read_file_lines').map(a => a.params?.path).filter(Boolean).length > 0 ? `- Tu as d√©j√† lu ces fichiers: ${[...new Set(previousActions.filter(a => a.action === 'read_file_lines').map(a => a.params?.path).filter(Boolean))].join(', ')} - NE LES RELIS PAS !` : ''}

üî• GESTION AUTOMATIQUE DES ERREURS COURANTES:
${previousActions.some(a => a.status === 'failed' && a.error?.includes('Address already in use')) ? '- ERREUR "Address already in use" d√©tect√©e ‚Üí G√©n√®re une commande pour tuer le processus existant (ex: "pkill python" ou "lsof -ti:8000 | xargs kill")' : ''}
${previousActions.some(a => a.status === 'failed' && a.error?.includes('Permission denied')) ? '- ERREUR "Permission denied" d√©tect√©e ‚Üí G√©n√®re une commande avec sudo ou change les permissions' : ''}
${previousActions.some(a => a.status === 'failed' && a.error?.includes('No such file')) ? '- ERREUR "No such file" d√©tect√©e ‚Üí V√©rifie le chemin exact ou cr√©e le fichier manquant' : ''}`;
  }

  const userPrompt = `T√¢che: "${task}"
${previousActionsContext}

ANALYSE la situation actuelle et d√©termine la PROCHAINE action unique √† effectuer.

üéØ INSTRUCTIONS CRITIQUES:
- UTILISE les r√©sultats des actions pr√©c√©dentes pour avancer intelligemment
- NE R√âP√àTE JAMAIS une action d√©j√† faite (surtout list_directory ou read_file_lines)
- Si tu as les informations n√©cessaires, PASSE √Ä L'ACTION (create_file, patch_file, etc.)
- LIMITE patch_file √† MAXIMUM 3-4 changements par action (JSON plus court = plus fiable)
- Pour de nombreuses modifications, DIVISE en plusieurs actions patch_file successives
- Sois EFFICACE et DIRECT dans tes choix
- Si une action pr√©c√©dente a √âCHOU√â, g√©n√®re automatiquement une action de CORRECTION (ne demande rien √† l'utilisateur)

üîß GESTION AUTOMATIQUE DES ERREURS:
- "Address already in use" ‚Üí run_command: "pkill python" ou "lsof -ti:PORT | xargs kill"
- "Permission denied" ‚Üí run_command avec sudo ou changement de permissions
- "No such file" ‚Üí create_file ou correction du chemin
- "Module not found" ‚Üí run_command: "pip install MODULE"

‚õî ANTI-LOOP RULES (VERY IMPORTANT):
- "File not found" for "xxx.js" ‚Üí Try "xxx.jsx"
- "File not found" again ‚Üí run_command: find . -name "*name*" -type f
- Fails 3 times in a row ‚Üí COMPLETELY change strategy
- Patch fails 2 times ‚Üí STOP and re-read entire file
- NEVER repeat exactly the same action that just failed

üéØ FORMAT DE R√âPONSE OBLIGATOIRE:

R√âPONDS UNIQUEMENT EN XML VALIDE - AUCUN TEXTE AVANT OU APR√àS LE XML.
‚ö†Ô∏è COMMENCE TOUJOURS PAR < ET TERMINE PAR >
UTILISE UNIQUEMENT UNE SEULE BALISE <tools> POUR L'ACTION SUIVANTE:

üö® COMMON ERRORS FOR ACTIONS:
‚ùå tools name="action">  ‚Üê WRONG: missing < at start  
‚úÖ <tools name="action"> ‚Üê CORRECT: with < at start
‚ùå <param name="path"="value" />  ‚Üê WRONG: incorrect syntax
‚úÖ <param name="path" value="value" />  ‚Üê CORRECT: name then value
‚ùå Patch already modified file ‚Üí RE-READ first with read_file_lines

<tools name="read_file_lines">
  <param name="path" value="fichier.ext" />
  <param name="start_line" value="1" />
  <param name="end_line" value="50" />
</tools>

OU

<tools name="patch_file">
  <param name="path" value="fichier.ext" />
  <changes>
    <change action="replace" line="15">
      <old>ancien texte exact</old>
      <new>nouveau texte</new>
    </change>
  </changes>
</tools>

OU

<tools name="run_command">
  <param name="cwd" value="." />
  <command>ls -la</command>
</tools>

EXEMPLES COMPLETS:

1. Cr√©er un fichier vide:
<tools name="create_file">
  <param name="path" value="server.log" />
</tools>

2. Cr√©er un fichier avec contenu:
<tools name="create_file">
  <param name="path" value="config.py" />
  <content># Configuration
port = 8000</content>
</tools>

3. Corriger une erreur "Address already in use":
<tools name="run_command">
  <param name="cwd" value="." />
  <command>pkill python</command>
</tools>

‚ö†Ô∏è CRITICAL RULES:
- GENERATE ONLY ONE <tools> TAG - NOT A COMPLETE PLAN
- BEFORE any patch_file: ALWAYS read_file_lines to see EXACT content
- In patch_file: include EXACTLY the indentation (spaces/tabs) from original file
- One line at a time in patch_file, no multi-line blocks
- If patch_file fails, it's often a spacing issue - re-read the file!`;

  try {
    const response = await makeAPICall([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ], {
      temperature: 0.1,
      max_tokens: 1000
    });

    // Afficher les informations sur les tokens
    if (response.usage) {
      console.log(chalk.gray(`üîÑ Action - Tokens: Envoy√©s ${response.usage.prompt_tokens} | Re√ßus ${response.usage.completion_tokens} | Total ${response.usage.total_tokens}`));
    }

    const rawContent = response.choices[0].message.content.trim();
    
    // Traiter les balises de r√©flexion
    const content = processThinkingResponse(rawContent, { showThinking: true });
    
    // Utiliser le parsing XML
    try {
      const action = parseXMLTool(content);
      
      // Validation basique de la structure
      if (!action || !action.action) {
        throw new Error("Structure XML invalide - action manquante");
      }
      
      // Convertir vers le format attendu par le syst√®me
      const parsed = {
        next_action: {
          action: action.action,
          params: action.params
        },
        status: "continue"
      };
      
      return parsed;
    } catch (parseError) {
      console.log(chalk.red(`‚ùå Erreur de parsing XML: ${parseError.message}`));
      console.log(chalk.yellow(`üìù Contenu re√ßu de l'IA:`));
      console.log(chalk.gray(`"${rawContent}"`));
      
      throw new Error(`Erreur de parsing XML de l'action: ${parseError.message}`);
    }

  } catch (error) {
    console.log(chalk.red(`‚ùå Erreur lors de la g√©n√©ration de l'action: ${error.message}`));
    throw error;
  }
}

/**
 * √âvalue le r√©sultat d'ex√©cution et g√©n√®re le prochain plan si n√©cessaire
 */
export async function evaluateAndContinue(task, executionResults, previousPlans = []) {

  // Extraire les erreurs r√©currentes pour √©viter de les r√©p√©ter
  const errors = [];
  const analyzedFiles = new Set();
  const analyzedFilesWithRanges = new Map(); // Track files with their line ranges
  const failedActions = new Set();
  const indentationErrors = [];
  
  // Normaliser les donn√©es pour g√©rer les deux formats possibles
  const normalizedResults = Array.isArray(executionResults) ? executionResults : [];
  
  normalizedResults.forEach(result => {
    // Format 1: result a une propri√©t√© results (ancien format)
    if (result.results && Array.isArray(result.results)) {
      result.results.forEach(actionResult => {
        if (actionResult.action?.action === 'analyze_file' && actionResult.action?.params?.path) {
          analyzedFiles.add(actionResult.action.params.path);
          
          const rangeKey = `${actionResult.action.params.path}:${actionResult.action.params.startLine || '0'}-${actionResult.action.params.endLine || 'end'}`;
          const count = analyzedFilesWithRanges.get(rangeKey) || 0;
          analyzedFilesWithRanges.set(rangeKey, count + 1);
        }
        if (!actionResult.success && actionResult.error) {
          errors.push(`${actionResult.action?.action || 'action'}: ${actionResult.error}`);
          failedActions.add(`${actionResult.action?.action}:${actionResult.action?.params?.path || ''}`);
          
          if (actionResult.error.includes('IndentationError')) {
            indentationErrors.push(actionResult.error);
          }
        }
      });
    }
    // Format 2: result est directement un completedStep (nouveau format)
    else if (result.action || result.description) {
      if (result.action === 'analyze_file' && result.params?.path) {
        analyzedFiles.add(result.params.path);
        
        const rangeKey = `${result.params.path}:${result.params.startLine || '0'}-${result.params.endLine || 'end'}`;
        const count = analyzedFilesWithRanges.get(rangeKey) || 0;
        analyzedFilesWithRanges.set(rangeKey, count + 1);
      }
      if (result.status !== 'completed' && result.error) {
        errors.push(`${result.action || result.description || 'action'}: ${result.error}`);
        failedActions.add(`${result.action}:${result.params?.path || ''}`);
        
        if (result.error.includes('IndentationError')) {
          indentationErrors.push(result.error);
        }
      }
    }
  });

  // D√©tecter les analyses r√©p√©t√©es
  const repeatedAnalyses = Array.from(analyzedFilesWithRanges.entries())
    .filter(([key, count]) => count >= 2)
    .map(([key, count]) => `${key} (${count} fois)`);

  const systemPrompt = `Tu es un agent IA expert en r√©solution de probl√®mes de d√©veloppement. Tu viens d'ex√©cuter un plan et dois maintenant √©valuer la situation avec pr√©cision.

üö® D√âTECTION DE BOUCLE:
${repeatedAnalyses.length > 0 ? `Tu as analys√© ces fichiers/plages PLUSIEURS FOIS:
${repeatedAnalyses.join('\n')}

STOP! Tu tournes en boucle. INTERDICTION de refaire analyze_file sur ces plages !` : ''}

IMPORTANT - APPRENTISSAGE DES ERREURS:
${errors.length > 0 ? `Tu as fait ces erreurs r√©cemment - NE LES R√âP√àTE PAS:
${errors.map(e => `- ${e}`).join('\n')}

R√àGLES POUR √âVITER LES ERREURS:
- Si un fichier n'existe pas, utilise d'abord "list_directory" pour voir ce qui est disponible
- Si tu cherches un fichier avec une extension manquante, ajoute l'extension appropri√©e (.py, .js, etc.)
- N'essaie JAMAIS d'analyser le m√™me fichier inexistant plusieurs fois
- Pour IndentationError Python : la ligne mentionn√©e dans l'erreur a besoin d'indentation (4 espaces)
- Si "expected an indented block after class definition", la ligne APR√àS le ':' doit √™tre indent√©e
- JAMAIS de patch_file avec old === new (√ßa ne change rien !)
- Si tu as d√©j√† analys√© un fichier, NE LE REFAIS PAS - passe √† l'action !
` : ''}

${indentationErrors.length > 0 ? `üö® ERREUR D'INDENTATION PERSISTANTE:
${indentationErrors[indentationErrors.length - 1]}

SOLUTION REQUISE pour IndentationError:
- Si "expected an indented block after class definition on line X", alors la ligne Y qui suit a besoin d'indentation
- Ajoute 4 espaces au d√©but de la ligne probl√©matique
- Exemple: change "def method(self):" en "    def method(self):" (4 espaces avant)
- OU ajoute "pass" indent√© si la classe est vide: "    pass"
- APR√àS un patch_file: run_command avec "python fichier.py" pour V√âRIFIER que l'erreur est corrig√©e
- NE JAMAIS refaire analyze_file apr√®s un patch_file sauf si l'erreur change
` : ''}

ACTIONS DISPONIBLES avec param√®tres requis:
- read_file_lines: {"path": "fichier.ext", "start_line": 1, "end_line": 50} - OBLIGATOIRE: minimum 10 lignes (recommand√© 30+ pour plus de contexte)
- create_file: {"path": "fichier.ext", "content": "contenu complet"}
- patch_file: {"path": "fichier.ext", "changes": [{"action": "replace", "line": 15, "old": "ancien texte", "new": "nouveau texte"}]}
- run_command: {"command": "commande shell", "cwd": ".", "timeout": 5000} - timeout optionnel en ms pour serveurs
- create_directory: {"path": "chemin/dossier"}
- list_directory: {"path": "chemin/repertoire"}

üïê UTILISATION DU TIMEOUT pour run_command:
- AJOUTE "timeout": 5000 (5 secondes) pour tester des serveurs/applications qui ne s'arr√™tent pas
- Exemples: python3 server.py, node app.js, npm start, uvicorn main:app
- Le processus sera automatiquement tu√© apr√®s le timeout
- Tu recevras stdout/stderr pour √©valuer si le serveur a bien d√©marr√©
- N'ajoute PAS de timeout pour des commandes normales (ls, cat, grep, etc.)

IMPORTANT POUR patch_file:
- Tu DOIS sp√©cifier les changements exacts avec "old" et "new"
- Si tu ne connais pas le contenu exact de la ligne, utilise "read_file_lines" d'abord avec minimum 50 lignes
- Ne g√©n√®re PAS de patch_file sans changements pr√©cis

R√âPONDS UNIQUEMENT EN JSON VALIDE - PAS DE MARKDOWN, PAS DE BACKTICKS, PAS DE TEXTE AVANT/APR√àS.`;

  const userPrompt = `üéØ T√ÇCHE ORIGINALE: "${task}"

üí¨ CONVERSATION COMPL√àTE (BRUTE - SANS INTERPR√âTATION):
${normalizedResults.map((result, index) => {
  const stepNum = index + 1;
  const action = result.action || result.description || 'Action inconnue';
  const status = result.status === 'completed' ? '‚úÖ' : '‚ùå';
  
  let conversation = `\n${stepNum}. ${status} ${action}`;
  
  // Montrer la sortie BRUTE/RAW de la commande ou action
  if (result.result && typeof result.result === 'string') {
    const rawResult = result.result.trim();
    if (rawResult) {
      conversation += `\n   SORTIE BRUTE:\n   ${rawResult.split('\n').map(line => `   ${line}`).join('\n')}`;
    }
  }
  
  // Montrer les erreurs aussi dans la conversation brute
  if (result.error && typeof result.error === 'string') {
    const rawError = result.error.trim();
    if (rawError) {
      conversation += `\n   ERREUR BRUTE:\n   ${rawError.split('\n').map(line => `   ${line}`).join('\n')}`;
    }
  }
  
  return conversation;
}).join('\n')}

üîç ACTIONS D√âJ√Ä EX√âCUT√âES ET LEURS R√âSULTATS:
${normalizedResults.map((r, index) => {
  // G√©rer les deux formats possibles
  let actionName, status, resultText = '';
  
  if (r.results && Array.isArray(r.results)) {
    // Format ancien: result contient results
    actionName = `Plan ${index + 1} (${r.results.length} actions)`;
    status = r.results.every(ar => ar.success) ? '‚úÖ' : '‚ùå';
    
    // Montrer les r√©sultats des actions individuelles
    const actionDetails = r.results.map(ar => {
      const arStatus = ar.success ? '‚úÖ' : '‚ùå';
      const arName = ar.action?.action || ar.description || 'action';
      return `${arStatus} ${arName}`;
    }).join(', ');
    resultText = `\n   Actions: ${actionDetails}`;
  } else {
    // Format nouveau: result est directement une action compl√©t√©e
    actionName = r.action || r.description || 'Action inconnue';
    status = r.status === 'completed' ? '‚úÖ' : '‚ùå';
    
    // Inclure les r√©sultats d√©taill√©s pour chaque action
    if (r.result && typeof r.result === 'string' && r.result.trim()) {
      // Limiter l'affichage des r√©sultats longs
      const lines = r.result.trim().split('\n');
      if (lines.length > 3) {
        resultText = `\n   R√©sultat: ${lines.slice(0, 3).join(', ')} ... (${lines.length} lignes total)`;
      } else {
        resultText = `\n   R√©sultat: ${r.result.trim()}`;
      }
    }
  }
  
  return `${index + 1}. ${status} ${actionName}${resultText}`;
}).join('\n')}

Fichiers d√©j√† analys√©s: ${Array.from(analyzedFiles).join(', ') || 'Aucun'}
Actions qui ont √©chou√©: ${Array.from(failedActions).join(', ') || 'Aucune'}

${repeatedAnalyses.length > 0 ? `\nüîÑ ALERTE BOUCLE: Tu as analys√© ${repeatedAnalyses.length} fichier(s) PLUSIEURS FOIS !
${repeatedAnalyses.join('\n')}

Si l'erreur persiste apr√®s plusieurs analyses, c'est que:
1. Le patch_file pr√©c√©dent n'a pas fonctionn√© (v√©rifier le texte exact)
2. L'erreur est ailleurs dans le fichier
3. Il faut une approche diff√©rente

INTERDICTION de refaire analyze_file sur les m√™mes plages !` : ''}

${errors.length > 0 ? `\n‚ö†Ô∏è ATTENTION: Tu as d√©j√† fait ${errors.length} erreur(s). Apprends de tes erreurs !` : ''}

üéØ √âVALUATION STRICTE DE LA T√ÇCHE ORIGINALE:

T√ÇCHE DEMAND√âE: "${task}"

ANALYSE DES R√âSULTATS OBTENUS:
${executionResults.map((r, index) => {
  const status = r.status === 'completed' ? '‚úÖ' : '‚ùå';
  const actionName = r.description || r.action || 'Action inconnue';
  
  // Analyser les r√©sultats pour extraire des informations utiles
  let insights = '';
  if (r.result && typeof r.result === 'string') {
    const result = r.result.toLowerCase();
    
    // D√©tecter des fichiers trouv√©s
    if (result.includes('./test.js') || result.includes('test.js')) {
      insights += ' ‚Üí test.js trouv√©';
    }
    
    // D√©tecter du contenu lu
    if (result.includes('function ') && result.includes('console.log')) {
      insights += ' ‚Üí contenu lu, fonctions d√©tect√©es';
    }
    
    // D√©tecter des modifications
    if (result.includes('modifi√©') || result.includes('ajout√©')) {
      insights += ' ‚Üí fichier modifi√©';
    }
  }
  
  return `${status} ${actionName}${insights}`;
}).join('\n')}

ü§î ANALYSE OBLIGATOIRE - NE PAS R√âP√âTER LES ACTIONS D√âJ√Ä FAITES:

1. FICHIERS D√âJ√Ä TROUV√âS: 
   ${executionResults.some(r => r.result && r.result.includes('./test.js')) ? '‚úÖ test.js est d√©j√† trouv√©/localis√©' : '‚ùå test.js pas encore trouv√©'}

2. CONTENU D√âJ√Ä LU:
   ${executionResults.some(r => r.result && r.result.includes('function ') && r.result.includes('add')) ? '‚úÖ test.js d√©j√† lu, contenu connu' : '‚ùå test.js pas encore lu'}

3. MODIFICATIONS D√âJ√Ä FAITES:
   ${executionResults.some(r => r.result && (r.result.includes('divide') || r.result.includes('modifi√©'))) ? '‚úÖ fonction divide d√©j√† ajout√©e' : '‚ùå fonction divide pas encore ajout√©e'}

üß† ANALYSE DE LA CONVERSATION BRUTE CI-DESSUS:

Regarde la sortie BRUTE des commandes ex√©cut√©es et d√©termine ce qui a R√âELLEMENT √©t√© fait.

‚ö†Ô∏è R√àGLES CRITIQUES POUR LIRE LES R√âSULTATS:

üìÅ FICHIERS TROUV√âS:
- SI tu vois "./test.js" dans une sortie de find ‚Üí test.js EST TROUV√â
- SI tu vois une liste de dossiers ‚Üí le r√©pertoire A √âT√â LIST√â

üìñ FICHIERS LUS:
- SI tu vois "üìÑ Contenu (X lignes):" suivi de code ‚Üí le fichier A √âT√â LU
- SI tu vois des num√©ros de lignes avec du code ‚Üí le contenu EST CONNU

üîß MODIFICATIONS R√âUSSIES:
- SI tu vois "‚úÖ Fichier modifi√© avec succ√®s" ‚Üí la modification EST TERMIN√âE
- SI tu vois "üìä X/X changement(s) appliqu√©(s)" ‚Üí le patch A FONCTIONN√â
- SI tu vois "üíæ Sauvegarde cr√©√©e" ‚Üí le fichier A √âT√â MODIFI√â

‚ùå MODIFICATIONS √âCHOU√âES:
- SI tu vois "‚ùå Aucun changement appliqu√©" ‚Üí le patch A √âCHOU√â
- SI tu vois "texte non trouv√©" ‚Üí il faut relire le fichier d'abord

üéØ D√âTERMINE LA PROCHAINE √âTAPE LOGIQUE:

En regardant la conversation brute ci-dessus, r√©ponds √† ces questions :

1. Y a-t-il un "‚úÖ Fichier modifi√© avec succ√®s" pour test.js ?
   ${normalizedResults.some(r => r.result && r.result.includes('‚úÖ Fichier modifi√© avec succ√®s') && r.result.includes('test.js')) ? '‚Üí OUI, test.js A √âT√â MODIFI√â' : '‚Üí NON, pas encore modifi√©'}

2. Y a-t-il un "üìä X/X changement(s) appliqu√©(s)" avec succ√®s ?
   ${normalizedResults.some(r => r.result && r.result.includes('changement(s) appliqu√©(s)') && !r.result.includes('‚ùå')) ? '‚Üí OUI, changements APPLIQU√âS' : '‚Üí NON, pas de changements appliqu√©s'}

3. La t√¢che "${task}" est-elle TERMIN√âE ?
   ${normalizedResults.some(r => r.result && r.result.includes('‚úÖ Fichier modifi√© avec succ√®s') && r.result.includes('test.js')) ? '‚Üí ‚úÖ OUI, T√ÇCHE TERMIN√âE' : '‚Üí ‚ùå NON, continuer'}

D√âCISION FINALE: ${normalizedResults.some(r => r.result && r.result.includes('‚úÖ Fichier modifi√© avec succ√®s') && r.result.includes('test.js')) ? 'status: "complete"' : 'status: "continue"'}

EXEMPLES CONCRETS:
- Si la t√¢che est "ajoute la function divide et son test dans test.js":
  * ‚ùå "continue" si tu as seulement trouv√© test.js (il faut encore ajouter la fonction ET le test)
  * ‚úÖ "complete" seulement si la fonction divide ET son test ont √©t√© ajout√©s √† test.js
  
- Si la t√¢che est "cr√©er un composant Button":
  * ‚ùå "continue" si tu as seulement cr√©√© le dossier (il faut encore cr√©er le fichier)
  * ‚úÖ "complete" seulement si le composant Button est enti√®rement cr√©√©

D√âCISION:
- "continue" : Il manque encore des √©l√©ments concrets de la t√¢che originale
- "complete" : TOUS les √©l√©ments demand√©s ont √©t√© enti√®rement accomplis

√âVITE absolument de refaire les m√™mes actions. Propose une NOUVELLE approche si n√©cessaire.

R√âPONDS UNIQUEMENT EN XML VALIDE - PAS DE MARKDOWN, PAS DE BACKTICKS:

Si la t√¢che est COMPLETE:
<status>complete</status>

Si la t√¢che doit CONTINUER avec des actions:
<status>continue</status>

<tools name="read_file_lines">
  <param name="path" value="fichier.ext" />
  <param name="start_line" value="1" />
  <param name="end_line" value="50" />
</tools>

<tools name="patch_file">
  <param name="path" value="fichier.ext" />
  <changes>
    <change action="replace" line="15">
      <old>ancien texte</old>
      <new>nouveau texte</new>
    </change>
  </changes>
</tools>`;

  try {
    const response = await makeAPICall([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ], {
      temperature: 0.1,
      max_tokens: 2000
    });

    // Afficher les informations sur les tokens pour evaluateAndContinue
    if (response.usage) {
      console.log(chalk.gray(`üîÑ √âvaluation - Tokens: Envoy√©s ${response.usage.prompt_tokens} | Re√ßus ${response.usage.completion_tokens} | Total ${response.usage.total_tokens}`));
    }

    const rawContent = response.choices[0].message.content.trim();
    
    // Traiter les balises de r√©flexion
    const content = processThinkingResponse(rawContent, { showThinking: true });
    
    try {
      // Extraire le statut
      const statusMatch = content.match(/<status>(complete|continue)<\/status>/);
      const status = statusMatch ? statusMatch[1] : "continue";
      
      if (status === "complete") {
        return { 
          plan: { 
            status: "complete",
            actions: []
          }
        };
      }
      
      // Extraire les actions
      const plan = parseXMLPlan(content);
      return { 
        plan: { 
          status: "continue",
          actions: plan.actions
        }
      };
    } catch (parseError) {
      throw new Error(`Erreur de parsing XML du plan: ${parseError.message}`);
    }

  } catch (error) {
    if (error.code === 'invalid_api_key') {
      throw new Error('Cl√© API invalide. V√©rifiez votre configuration avec "tera config"');
    } else if (error.code === 'insufficient_quota') {
      throw new Error('Quota insuffisant. V√©rifiez votre compte');
    } else if (error.message.includes('non configur√©e')) {
      throw new Error('Cl√© API non configur√©e. Utilisez "tera config" pour la configurer');
    } else if (error.status === 401) {
      throw new Error('Cl√© API invalide ou expir√©e. V√©rifiez votre configuration avec "tera config"');
    } else if (error.status === 429) {
      throw new Error('Limite de requ√™tes atteinte. Attendez un moment avant de r√©essayer');
    } else if (error.status === 404 && error.message.includes('model')) {
      const activeConfig = getActiveConfig();
      throw new Error(`Mod√®le "${activeConfig.model}" non trouv√©. V√©rifiez votre configuration avec "tera config"`);
    } else {
      throw new Error(`Erreur IA: ${error.message}`);
    }
  }
}

/**
 * G√©n√®re un nouveau plan avec des instructions sp√©cifiques de l'utilisateur
 */
export async function generateCorrectedPlan(task, userInstructions, previousContext = {}) {

  const systemPrompt = `Tu es un agent IA autonome expert en d√©veloppement. L'utilisateur t'a donn√© des instructions sp√©cifiques pour corriger ou am√©liorer ta strat√©gie.

MISSION: G√©n√©rer un nouveau plan bas√© sur les instructions de l'utilisateur.

INSTRUCTIONS UTILISATEUR: "${userInstructions}"

TU DOIS:
- Prendre en compte les instructions sp√©cifiques de l'utilisateur
- Adapter ta strat√©gie en cons√©quence  
- G√©n√©rer des actions concr√®tes et correctes
- Expliquer comment tu prends en compte les instructions

ACTIONS DISPONIBLES (avec param√®tres requis):
- read_file_lines: {"path": "fichier.ext", "start_line": 1, "end_line": 50} - OBLIGATOIRE: minimum 10 lignes (recommand√© 30+ pour plus de contexte)
- create_file: {"path": "fichier.ext", "content": "contenu complet"}
- patch_file: {"path": "fichier.ext", "changes": [{"action": "replace", "line": 15, "old": "texte exact actuel", "new": "nouveau texte"}]}
- run_command: {"command": "commande shell", "cwd": ".", "timeout": 5000} - timeout optionnel en ms pour serveurs
- create_directory: {"path": "chemin/dossier"}
- list_directory: {"path": "chemin/repertoire"}

R√àGLES CRITIQUES POUR patch_file:
- Tu DOIS lire le fichier d'abord pour conna√Ætre le contenu exact
- Pour erreur ligne N sp√©cifique: read_file_lines avec minimum 50 lignes autour de l'erreur !
- Tu DOIS sp√©cifier le texte exact dans "old" qui existe vraiment dans le fichier
- PAS de patch_file sans conna√Ætre le contenu exact de la ligne
- EXEMPLE: erreur ligne 15 ‚Üí read_file_lines avec start_line=1, end_line=50 (minimum 50 lignes)`;

  const userPrompt = `T√ÇCHE ORIGINALE: "${task}"

INSTRUCTIONS SP√âCIFIQUES DE L'UTILISATEUR: "${userInstructions}"

CONTEXTE PR√âC√âDENT:
${JSON.stringify(previousContext, null, 2)}

R√©pertoire de travail: ${process.cwd()}

G√©n√®re maintenant un nouveau plan qui prend en compte les instructions de l'utilisateur.

R√âPONDS UNIQUEMENT EN JSON VALIDE - PAS DE MARKDOWN:
{
  "analysis": "ton analyse de la situation et comment tu prends en compte les instructions",
  "strategy": "ta nouvelle strat√©gie bas√©e sur les instructions utilisateur", 
  "status": "continue|complete",
  "reasoning": "pourquoi cette approche r√©pond aux instructions de l'utilisateur",
  "actions": [
    {
      "action": "create_file|modify_file|patch_file|run_command|create_directory|read_file_lines|list_directory",
      "description": "Description lisible de l'action", 
      "params": { /* param√®tres complets */ }
    }
  ]
}

STATUTS OBLIGATOIRES:
- "continue": Tu as du travail √† faire avec cette nouvelle approche
- "complete": La t√¢che est termin√©e selon les instructions utilisateur

R√àGLE CRITIQUE: TOUJOURS inclure TOUS les param√®tres requis dans "params"
R√àGLE IMPORTANTE: Explique clairement comment tu prends en compte les instructions utilisateur`;

  try {
    const response = await makeAPICall([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ], {
      temperature: 0.1,
      max_tokens: 2000
    });

    // Afficher les informations sur les tokens pour evaluateAndContinue
    if (response.usage) {
      console.log(chalk.gray(`üîÑ √âvaluation - Tokens: Envoy√©s ${response.usage.prompt_tokens} | Re√ßus ${response.usage.completion_tokens} | Total ${response.usage.total_tokens}`));
    }

    const rawContent = response.choices[0].message.content.trim();
    
    // Traiter les balises de r√©flexion
    const content = processThinkingResponse(rawContent, { showThinking: true });
    
    try {
      const parsed = JSON.parse(content);
      return { plan: parsed };
    } catch (parseError) {
      // Essayer de nettoyer le JSON
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          const parsed = JSON.parse(jsonMatch[0]);
          return { plan: parsed };
        } catch (secondParseError) {
          // √âchec m√™me apr√®s nettoyage
        }
      }
      
      throw new Error("Erreur de parsing JSON du plan corrig√©");
    }

  } catch (error) {
    if (error.code === 'invalid_api_key') {
      throw new Error('Cl√© API invalide. V√©rifiez votre configuration avec "tera config"');
    } else if (error.code === 'insufficient_quota') {
      throw new Error('Quota insuffisant. V√©rifiez votre compte');
    } else if (error.message.includes('non configur√©e')) {
      throw new Error('Cl√© API non configur√©e. Utilisez "tera config" pour la configurer');
    } else if (error.status === 401) {
      throw new Error('Cl√© API invalide ou expir√©e. V√©rifiez votre configuration avec "tera config"');
    } else if (error.status === 429) {
      throw new Error('Limite de requ√™tes atteinte. Attendez un moment avant de r√©essayer');
    } else if (error.status === 404 && error.message.includes('model')) {
      const activeConfig = getActiveConfig();
      throw new Error(`Mod√®le "${activeConfig.model}" non trouv√©. V√©rifiez votre configuration avec "tera config"`);
    } else {
      throw new Error(`Erreur IA: ${error.message}`);
    }
  }
}

/**
 * Obtient des informations sur la configuration active
 */
export function getAIInfo() {
  const activeConfig = getActiveConfig();
  
  return {
    provider: activeConfig.provider,
    model: activeConfig.model,
    hasApiKey: !!activeConfig.apiKey,
    baseURL: activeConfig.baseURL
  };
} 

/**
 * R√©cup√®re la liste des mod√®les disponibles via l'API
 */
export async function fetchAvailableModels() {
  try {
    const client = getOpenAIClient();
    const activeConfig = getActiveConfig();
    
    if (activeConfig.provider === PROVIDERS.OPENAI) {
      // R√©cup√©rer les mod√®les OpenAI via l'API
      const response = await client.models.list();
      
      // Filtrer pour ne garder que les mod√®les de chat completion
      const chatModels = response.data
        .filter(model => {
          const id = model.id.toLowerCase();
          return (
            id.includes('gpt') && 
            !id.includes('instruct') && 
            !id.includes('embedding') && 
            !id.includes('whisper') &&
            !id.includes('tts') &&
            !id.includes('dall-e') &&
            !id.includes('realtime')
          );
        })
        .map(model => ({
          id: model.id,
          object: model.object,
          created: model.created,
          owned_by: model.owned_by
        }))
        .sort((a, b) => {
          // Trier par pr√©f√©rence: gpt-4o > gpt-4 > gpt-3.5
          const order = ['gpt-4o', 'gpt-4', 'gpt-3.5'];
          const aPrefix = order.find(prefix => a.id.startsWith(prefix)) || 'zzz';
          const bPrefix = order.find(prefix => b.id.startsWith(prefix)) || 'zzz';
          
          if (aPrefix !== bPrefix) {
            return order.indexOf(aPrefix) - order.indexOf(bPrefix);
          }
          
          return a.id.localeCompare(b.id);
        });
      
      return {
        provider: PROVIDERS.OPENAI,
        models: chatModels
      };
      
    } else if (activeConfig.provider === PROVIDERS.OPENROUTER) {
      // Pour OpenRouter, utiliser l'API des mod√®les
      const response = await fetch('https://openrouter.ai/api/v1/models', {
        headers: {
          'Authorization': `Bearer ${activeConfig.apiKey}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      const models = data.data
        .filter(model => model.id && !model.id.includes('moderation'))
        .map(model => ({
          id: model.id,
          name: model.name || model.id,
          description: model.description,
          context_length: model.context_length,
          pricing: model.pricing
        }))
        .sort((a, b) => {
          // Trier par popularit√©/qualit√©
          const popularModels = ['openai/gpt-4o', 'openai/gpt-4', 'anthropic/claude-3', 'meta-llama/llama-3'];
          const aPopular = popularModels.some(prefix => a.id.startsWith(prefix));
          const bPopular = popularModels.some(prefix => b.id.startsWith(prefix));
          
          if (aPopular && !bPopular) return -1;
          if (!aPopular && bPopular) return 1;
          
          return a.name.localeCompare(b.name);
        });
      
      return {
        provider: PROVIDERS.OPENROUTER,
        models: models
      };
      
    } else if (activeConfig.provider === PROVIDERS.OLLAMA) {
      // Pour Ollama, utiliser l'endpoint /api/tags
      const baseURL = activeConfig.baseURL.replace('/v1', '');
      const response = await fetch(`${baseURL}/api/tags`);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      const models = data.models.map(model => ({
        id: model.name,
        name: model.name,
        size: model.size,
        modified_at: model.modified_at,
        family: model.details?.family || 'Unknown',
        digest: model.digest
      }))
      .sort((a, b) => {
        // Trier par date de modification (plus r√©cent en premier)
        if (a.modified_at && b.modified_at) {
          return new Date(b.modified_at) - new Date(a.modified_at);
        }
        return a.name.localeCompare(b.name);
      });
      
      return {
        provider: PROVIDERS.OLLAMA,
        models: models
      };
      
    } else if (activeConfig.provider === PROVIDERS.ANTHROPIC) {
      // Pour Anthropic, utiliser une liste de mod√®les r√©ellement disponibles
      // Anthropic ne fournit pas d'endpoint public pour lister tous les mod√®les
      const popularModels = [
        {
          id: 'claude-3-5-sonnet-20241022',
          name: 'Claude 3.5 Sonnet',
          description: 'Most intelligent model, ideal for complex tasks',
          context_length: 200000,
          created: '2024-10-22T00:00:00Z'
        },
        {
          id: 'claude-3-5-haiku-20241022',
          name: 'Claude 3.5 Haiku',
          description: 'Fastest model, great for simple tasks and quick responses',
          context_length: 200000,
          created: '2024-10-22T00:00:00Z'
        },
        {
          id: 'claude-3-opus-20240229',
          name: 'Claude 3 Opus',
          description: 'Most powerful model for highly complex tasks',
          context_length: 200000,
          created: '2024-02-29T00:00:00Z'
        },
        {
          id: 'claude-3-sonnet-20240229',
          name: 'Claude 3 Sonnet',
          description: 'Balance of intelligence and speed',
          context_length: 200000,
          created: '2024-02-29T00:00:00Z'
        },
        {
          id: 'claude-3-haiku-20240307',
          name: 'Claude 3 Haiku',
          description: 'Fast and cost-effective',
          context_length: 200000,
          created: '2024-03-07T00:00:00Z'
        }
      ];
      
      // Optionnel: v√©rifier la disponibilit√© des mod√®les via l'API
      const availableModels = [];
      for (const model of popularModels) {
        try {
          // Tenter de r√©cup√©rer les informations du mod√®le pour v√©rifier sa disponibilit√©
          const response = await fetch(`${activeConfig.baseURL}/v1/models/${model.id}`, {
            headers: {
              'x-api-key': activeConfig.apiKey,
              'anthropic-version': '2023-06-01'
            }
          });
          
          if (response.ok) {
            const modelData = await response.json();
            availableModels.push({
              id: modelData.id,
              name: modelData.display_name || model.name,
              description: model.description,
              context_length: model.context_length,
              created: modelData.created_at || model.created,
              type: modelData.type || 'model'
            });
          } else {
            // Si le mod√®le n'est pas accessible, l'ajouter quand m√™me √† la liste
            availableModels.push(model);
          }
        } catch (error) {
          // En cas d'erreur, ajouter le mod√®le √† la liste par d√©faut
          availableModels.push(model);
        }
      }
      
      return {
        provider: PROVIDERS.ANTHROPIC,
        models: availableModels
      };
    }
    
    throw new Error('Provider non support√© pour la r√©cup√©ration de mod√®les');
    
  } catch (error) {
    if (error.code === 'invalid_api_key') {
      throw new Error('Cl√© API invalide. V√©rifiez votre configuration avec "tera config"');
    } else if (error.code === 'insufficient_quota') {
      throw new Error('Quota insuffisant. V√©rifiez votre compte');
    } else if (error.message.includes('non configur√©e')) {
      throw new Error('Cl√© API non configur√©e. Utilisez "tera config" pour la configurer');
    } else if (error.status === 401) {
      throw new Error('Cl√© API invalide ou expir√©e. V√©rifiez votre configuration avec "tera config"');
    } else if (error.status === 429) {
      throw new Error('Limite de requ√™tes atteinte. Attendez un moment avant de r√©essayer');
    } else if (error.code === 'ECONNREFUSED' || error.message.includes('ECONNREFUSED')) {
      const activeConfig = getActiveConfig();
      if (activeConfig.provider === PROVIDERS.OLLAMA) {
        throw new Error('Impossible de se connecter √† Ollama. V√©rifiez qu\'Ollama est d√©marr√© avec "ollama serve"');
      }
      throw new Error('Impossible de se connecter au service');
    } else {
      throw new Error(`Erreur lors de la r√©cup√©ration des mod√®les: ${error.message}`);
    }
  }
}

/**
 * R√©cup√®re les informations d√©taill√©es d'un mod√®le sp√©cifique
 */
export async function fetchModelInfo(modelId) {
  try {
    const client = getOpenAIClient();
    const activeConfig = getActiveConfig();
    
    if (activeConfig.provider === PROVIDERS.OPENAI) {
      // R√©cup√©rer les infos du mod√®le OpenAI
      const model = await client.models.retrieve(modelId);
      
      return {
        id: model.id,
        object: model.object,
        created: model.created,
        owned_by: model.owned_by,
        provider: PROVIDERS.OPENAI
      };
      
    } else if (activeConfig.provider === PROVIDERS.OPENROUTER) {
      // Pour OpenRouter, chercher dans la liste des mod√®les
      const modelsData = await fetchAvailableModels();
      const model = modelsData.models.find(m => m.id === modelId);
      
      return model || null;
      
    } else if (activeConfig.provider === PROVIDERS.OLLAMA) {
      // Pour Ollama, utiliser l'endpoint /api/show
      const baseURL = activeConfig.baseURL.replace('/v1', '');
      const response = await fetch(`${baseURL}/api/show`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ name: modelId })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      return {
        id: data.modelfile || modelId,
        name: modelId,
        details: data.details,
        parameters: data.parameters,
        template: data.template,
        provider: PROVIDERS.OLLAMA
      };
    }
    
    throw new Error('Provider non support√© pour la r√©cup√©ration d\'informations de mod√®le');
    
  } catch (error) {
    if (error.message.includes('model not found') || error.status === 404) {
      return null;
    }
    throw error;
  }
}

/**
 * R√©cup√®re la liste des mod√®les disponibles avec une cl√© API sp√©cifique (pour la configuration)
 * @param {string} provider - Le provider (PROVIDERS.OPENAI, PROVIDERS.ANTHROPIC, etc.)
 * @param {string} apiKey - La cl√© API √† utiliser
 */
export async function fetchAvailableModelsWithKey(provider, apiKey) {
  if (provider === PROVIDERS.ANTHROPIC) {
    // Pour Anthropic, utiliser la liste de mod√®les r√©ellement disponibles avec validation
    const popularModels = [
      {
        id: 'claude-3-5-sonnet-20241022',
        name: 'Claude 3.5 Sonnet',
        description: 'Most intelligent model, ideal for complex tasks',
        context_length: 200000,
        created: '2024-10-22T00:00:00Z'
      },
      {
        id: 'claude-3-5-haiku-20241022',
        name: 'Claude 3.5 Haiku',
        description: 'Fastest model, great for simple tasks and quick responses',
        context_length: 200000,
        created: '2024-10-22T00:00:00Z'
      },
      {
        id: 'claude-3-opus-20240229',
        name: 'Claude 3 Opus',
        description: 'Most powerful model for highly complex tasks',
        context_length: 200000,
        created: '2024-02-29T00:00:00Z'
      },
      {
        id: 'claude-3-sonnet-20240229',
        name: 'Claude 3 Sonnet',
        description: 'Balance of intelligence and speed',
        context_length: 200000,
        created: '2024-02-29T00:00:00Z'
      },
      {
        id: 'claude-3-haiku-20240307',
        name: 'Claude 3 Haiku',
        description: 'Fast and cost-effective',
        context_length: 200000,
        created: '2024-03-07T00:00:00Z'
      }
    ];
    
    // Tester la cl√© API avec le premier mod√®le pour valider l'acc√®s
    try {
      const testResponse = await fetch(`https://api.anthropic.com/v1/models/${popularModels[0].id}`, {
        headers: {
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01'
        }
      });
      
      if (testResponse.ok) {
        console.log(chalk.green('‚úÖ Cl√© API Anthropic valid√©e avec succ√®s'));
      } else if (testResponse.status === 401) {
        throw new Error('Cl√© API invalide ou expir√©e');
      } else if (testResponse.status === 403) {
        throw new Error('Acc√®s refus√© - v√©rifiez vos permissions');
      }
    } catch (error) {
      if (error.message.includes('Cl√© API invalide')) {
        throw error;
      }
      // En cas d'erreur r√©seau, continuer quand m√™me avec la liste
      console.log(chalk.yellow('‚ö†Ô∏è  Impossible de valider la cl√© API, mais utilisation de la liste par d√©faut'));
    }
    
    return {
      provider: PROVIDERS.ANTHROPIC,
      models: popularModels
    };
  }
  
  // Pour les autres providers, utiliser la logique existante
  throw new Error(`fetchAvailableModelsWithKey non impl√©ment√© pour le provider: ${provider}`);
} 

/**
 * Fonction robuste pour nettoyer et parser du JSON avec diagnostics d√©taill√©s
 * @param {string} content - Le contenu √† parser
 * @param {Object} options - Options de debug
 * @returns {Object} - L'objet pars√© ou throw une erreur d√©taill√©e
 */
function cleanAndParseJSON(content, options = {}) {
  const { debug = false, context = "unknown" } = options;
  
  if (debug) {
    console.log(chalk.gray(`üîç Debug JSON parsing pour ${context}:`));
    console.log(chalk.gray(`   Content brut (${content.length} chars): "${content.substring(0, 200)}${content.length > 200 ? '...' : ''}"`));
  }
  
  // Strat√©gie 1: Essayer le parsing direct
  try {
    const parsed = JSON.parse(content);
    if (debug) console.log(chalk.green(`   ‚úÖ Parsing direct r√©ussi`));
    return parsed;
  } catch (directError) {
    if (debug) console.log(chalk.yellow(`   ‚ö†Ô∏è Parsing direct √©chou√©: ${directError.message}`));
  }
  
  // Strat√©gie 2: Chercher et extraire le JSON principal
  const jsonPatterns = [
    // JSON complet avec accolades
    /\{[\s\S]*\}/,
    // JSON avec possibles caract√®res avant/apr√®s
    /.*?(\{[\s\S]*\}).*?/,
    // JSON multiligne avec espaces
    /\n\s*(\{[\s\S]*\})\s*\n?/,
    // JSON avec backticks markdown
    /```(?:json)?\s*(\{[\s\S]*\})\s*```/i,
    // JSON avec balises de code
    /<code[^>]*>(\{[\s\S]*\})<\/code>/i
  ];
  
  for (let i = 0; i < jsonPatterns.length; i++) {
    const pattern = jsonPatterns[i];
    const match = content.match(pattern);
    
    if (match) {
      const extractedJson = match[1] || match[0];
      if (debug) console.log(chalk.gray(`   üîÑ Tentative pattern ${i + 1}: "${extractedJson.substring(0, 100)}..."`));
      
      try {
        const parsed = JSON.parse(extractedJson);
        if (debug) console.log(chalk.green(`   ‚úÖ Pattern ${i + 1} r√©ussi`));
        return parsed;
      } catch (patternError) {
        if (debug) console.log(chalk.yellow(`   ‚ö†Ô∏è Pattern ${i + 1} √©chou√©: ${patternError.message}`));
      }
    }
  }
  
  // Strat√©gie 3: Nettoyage agressif et r√©paration des JSON tronqu√©s
  let cleanedContent = content
    // Supprimer les backticks markdown
    .replace(/```(?:json)?\s*/gi, '')
    .replace(/```\s*/g, '')
    // Supprimer les balises HTML/XML
    .replace(/<[^>]*>/g, '')
    // Supprimer les commentaires JavaScript/JSON5
    .replace(/\/\*[\s\S]*?\*\//g, '')
    .replace(/\/\/.*$/gm, '')
    // G√©rer les apostrophes fran√ßaises AVANT de remplacer toutes les quotes
    .replace(/([a-zA-Z])'([a-zA-Z])/g, '$1\u2019$2') // Remplacer l'apostrophe par un caract√®re Unicode
    // Normaliser les guillemets
    .replace(/'/g, '"')
    // Restaurer les apostrophes fran√ßaise
    .replace(/\u2019/g, "'")
    // Supprimer les caract√®res de contr√¥le sauf \n, \r, \t
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
    // Supprimer les espaces en d√©but/fin
    .trim();
  
  // Strat√©gie 3.1: R√©parer les JSON tronqu√©s
  if (cleanedContent.endsWith(',') || cleanedContent.endsWith('"') || !cleanedContent.endsWith('}')) {
    if (debug) console.log(chalk.gray(`   üîß Tentative de r√©paration d'un JSON tronqu√©`));
    
    // Chercher la derni√®re structure compl√®te
    let depth = 0;
    let lastCompleteIndex = -1;
    let inString = false;
    let escaped = false;
    
    for (let i = cleanedContent.length - 1; i >= 0; i--) {
      const char = cleanedContent[i];
      
      if (!inString) {
        if (char === '}') depth++;
        else if (char === '{') depth--;
        
        if (depth === 0 && char === '}') {
          lastCompleteIndex = i;
          break;
        }
      }
      
      if (char === '"' && !escaped) {
        inString = !inString;
      }
      escaped = (char === '\\' && !escaped);
    }
    
    if (lastCompleteIndex > 0) {
      const repairedContent = cleanedContent.substring(0, lastCompleteIndex + 1);
      if (debug) console.log(chalk.gray(`   üîß JSON r√©par√© (tronqu√© √† ${lastCompleteIndex + 1}/${cleanedContent.length})`));
      cleanedContent = repairedContent;
    }
  }
  
  if (debug) console.log(chalk.gray(`   üßπ Contenu nettoy√©: "${cleanedContent.substring(0, 200)}..."`));
  
  try {
    const parsed = JSON.parse(cleanedContent);
    if (debug) console.log(chalk.green(`   ‚úÖ Nettoyage agressif r√©ussi`));
    return parsed;
  } catch (cleanError) {
    if (debug) console.log(chalk.yellow(`   ‚ö†Ô∏è Nettoyage agressif √©chou√©: ${cleanError.message}`));
  }
  
  // Strat√©gie 4: Extraire champ par champ si possible
  try {
    const fields = {};
    
    // Chercher les champs individuellement avec patterns am√©lior√©s
    const fieldPatterns = {
      analysis: /"analysis"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/,
      next_action: /"next_action"\s*:\s*(\{[\s\S]*?\})\s*(?:,|\}|$)/,
      status: /"status"\s*:\s*"([^"]*)"/ 
    };
    
         let foundFields = 0;
     for (const [field, pattern] of Object.entries(fieldPatterns)) {
       const match = content.match(pattern);
       if (match) {
         try {
           if (field === 'next_action') {
             // Nettoyer l'objet next_action avant parsing
             let actionJson = match[1];
             
             // R√©parer les objets next_action tronqu√©s en cherchant les patterns d'action
             if (!actionJson.includes('"action"') && content.includes('"action"')) {
               // Extraire directement les composants de l'action
               const actionMatch = content.match(/"action"\s*:\s*"([^"]+)"/);
               const descMatch = content.match(/"description"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/);
               const paramsMatch = content.match(/"params"\s*:\s*(\{[\s\S]*?\})/);
               
               if (actionMatch) {
                 const reconstructed = {
                   action: actionMatch[1],
                   description: descMatch ? descMatch[1] : "Action reconstruite",
                   params: {}
                 };
                 
                 if (paramsMatch) {
                   try {
                     reconstructed.params = JSON.parse(paramsMatch[1]);
                   } catch (paramError) {
                     // Garder params vide si parsing √©choue
                   }
                 }
                 
                 fields[field] = reconstructed;
                 foundFields++;
                 if (debug) console.log(chalk.cyan(`   üîß Champ ${field} reconstruit: ${JSON.stringify(fields[field]).substring(0, 50)}...`));
                 continue;
               }
             }
             
             fields[field] = JSON.parse(actionJson);
           } else {
             fields[field] = match[1];
           }
           foundFields++;
           if (debug) console.log(chalk.gray(`   üîß Champ ${field} extrait: ${JSON.stringify(fields[field]).substring(0, 50)}...`));
         } catch (fieldError) {
           if (debug) console.log(chalk.yellow(`   ‚ö†Ô∏è Extraction du champ ${field} √©chou√©e: ${fieldError.message}`));
         }
       }
     }
    
    if (foundFields > 0) {
      if (debug) console.log(chalk.green(`   ‚úÖ Extraction par champs r√©ussie (${foundFields} champs)`));
      return fields;
    }
  } catch (extractError) {
    if (debug) console.log(chalk.yellow(`   ‚ö†Ô∏è Extraction par champs √©chou√©e: ${extractError.message}`));
  }
  
  // Strat√©gie 5: Fallback avec structure minimale
  if (debug) {
    console.log(chalk.red(`   ‚ùå Toutes les strat√©gies ont √©chou√©`));
    console.log(chalk.gray(`   üìù Contenu probl√©matique:`));
    console.log(chalk.gray(`   "${content}"`));
  }
  
  // Si rien n'a fonctionn√©, essayer de cr√©er une structure minimale
  const hasAction = content.toLowerCase().includes('patch_file') || 
                   content.toLowerCase().includes('read_file') ||
                   content.toLowerCase().includes('create_file') ||
                   content.toLowerCase().includes('run_command');
                   
  if (hasAction) {
    // Essayer de deviner l'action principale et extraire plus d'infos
    let guessedAction = 'read_file_lines';
    let extractedParams = {};
    let extractedDescription = "Action reconstruite apr√®s erreur de parsing";
    
    if (content.includes('patch_file')) {
      guessedAction = 'patch_file';
      // Essayer d'extraire le path
      const pathMatch = content.match(/"path"\s*:\s*"([^"]+)"/);
      if (pathMatch) {
        extractedParams.path = pathMatch[1];
        extractedDescription = `Patch du fichier ${pathMatch[1]} (simplifi√© apr√®s erreur JSON)`;
      }
      
      // Cr√©er des changements minimaux pour √©viter les erreurs
      extractedParams.changes = [{
        action: "replace",
        line: 1,
        old: "// Placeholder",
        new: "// Patch reconstruit - v√©rifiez le contenu"
      }];
      
    } else if (content.includes('create_file')) {
      guessedAction = 'create_file';
      const pathMatch = content.match(/"path"\s*:\s*"([^"]+)"/);
      if (pathMatch) {
        extractedParams.path = pathMatch[1];
        extractedDescription = `Cr√©ation du fichier ${pathMatch[1]} (simplifi√© apr√®s erreur JSON)`;
      }
    } else if (content.includes('run_command')) {
      guessedAction = 'run_command';
      const cmdMatch = content.match(/"command"\s*:\s*"([^"]+)"/);
      if (cmdMatch) {
        extractedParams.command = cmdMatch[1];
        extractedDescription = `Ex√©cution: ${cmdMatch[1]} (simplifi√© apr√®s erreur JSON)`;
      }
    }
    
    const fallbackStructure = {
      analysis: "Erreur de parsing JSON - structure reconstruite avec infos partielles",
      next_action: {
        action: guessedAction,
        description: extractedDescription,
        params: extractedParams
      },
      status: "continue"
    };
    
    if (debug) console.log(chalk.cyan(`   üîÑ Fallback avec structure enrichie pour ${guessedAction}: ${JSON.stringify(extractedParams)}`));
    return fallbackStructure;
  }
  
  throw new Error(`Impossible de parser le JSON apr√®s toutes les strat√©gies de nettoyage. Contenu: ${content.substring(0, 200)}...`);
}